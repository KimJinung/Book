# 클린 아키텍처

## 1. 디자인과 아키텍처 그리고 가치
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데에 투입되는 비용을 최소화하는 것에 있다. 소프트웨어 시스템은 이해 관계자에게 행위와 구조라는 두 가지 가치를 제공한다.

### - 행위
프로그래머를 고용하는 이유는 기계를 이용하여 수익을 창출하고 고용 비용을 절약하기 위함이다.

### - 구조
Soft + ware는 부드러운 제품이다. Hardware는 한 번 생산하면 변경하는 것이 어렵다. 하지만 소프트웨어는 변경 사항에 유연하고 쉽게 대처가 가능하다. 즉 소프트웨어의 본질은 변경이 쉽다는 것이다.

프로그래머는 시간이 지날수록 유지보수를 위해 시간과 비용이 많이 들어가는 것을 피하기 위한 투쟁을 해야한다. 이것이 프로그래머를 고용하는 이유이며 소프트웨어 아키텍처가 중요한 이유다.

## 2. 프로그래밍 패러다임
프로그래밍 패러다임에는 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍이 존재한다. 이 3가지 외에는 존재하지 않는다.

- 구조적 프로그래밍: if, else, for 구문을 통해 제어흐름의 직접 전환을 제한한다.
- 객체지향 프로그래밍: 제어흐름의 간접 전환에 규율을 부과하여 소스 코드의 의존성에 대한 제어 권한을 획득한다.
- 함수형 프로그래밍: 변수 할당에 규율을 부과한다. (함수형 언어에는 변수가 없으며 이로인해 race condition이 발생하지 않는다.)

## 3. SOLID

### - SRP(Single Responsibility Principle)
모듈이 하나의 이해관계자만 상대하는 것을 의미하게 한다. (모듈이 한 가지 일만 하는 것을 의미하는 것이 아니다.)
### - OCP(Open Closed Prinsicple)
확장에는 열려있고 변경에는 닫혀있어야 한다. (transitive dependency를 조심해야한다.)
### - LSP(Liskov Substitution Principle)
상속을 통해 생성한 구현체가 상위 타입으로 치환될 때 행위가 변하지 않으면 구현체는 상위 타입의 하위타입이다.
### - ISP(Interface Segregation Principle)
필요 이상 많은 걸 포함하는 모듈에 의존하지 않도록 인터페이스를 분리한다.
### - DIP(Dependency Inversion Principle)
변동성이 큰 구체 클래스를 참조하지 않으며, 구체 클래스를 오버라이드 하지 않는다.
인터페이스를 참조하며 인터페이스 메서드를 오버라이드하여 각각 구현한다.

## 4. Component
컴포넌트는 배포의 단위다. SOLID가 방을 짓기 위한 작업이라면 Compoent 아키텍처는 빌딩에 방을 배치하는 작업이다.
