# 프로그래밍 패러다임
### 패러다임의 시대
토마스 쿤은 과학혁명이라는 저서에서 처음으로 패러다임이라는 용어를 사용했다. 

### 프로그래밍 패러다임
프로그래밍 분야에서 '패러다임'의 개념을 받아들였다. 토마스 쿤이 사용한 패러다임은 서로 비교가 불가능하지만, 
프로그래밍 분야에서 사용하는 패러다임이라는 용어는 서로가 공존할 수 있다. 그 예시로 스칼라는 객체 지향 프로그래밍과 함수형 프로그래밍이 공존하고 있다.
객체 지향이 만능은 아니다. 객체 지향 패러다임이 적절하지 않은 영역에서 적절한 패러다임을 적용할 수 있는 안목을 기르는 것이 중요하다.


## 1. 객체
### 절차 지향과 객체 지향
절차 지향은 프로세스와 데이터로 구성된다. 절차 지향은 프로세스가 데이터에 의존하므로 로직이 변경되면 변경 지점이 다수 발생한다.
객체 지향은 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍한다. 자신의 데이터를 자신 스스로 해결함으로써 응집성을 높이고 결합도를 낮춘다.

---
토이 프로젝트를 진행하면서 내가 작성한 유스 케이스는 절차 지향에 더 가까운 설계다. 이로인해 변경에 더 취약했던 것으로 생각된다.

나는 useCase에서 각 도메인에 의존해서 처리했는데, order 유스 케이스는 order 도메인에게 주문을 생성하라는 메서드에 DTO 클래스만 넘기고,
실제로 주문에 대한 로직을 수행하는 것은 order 엔티티가 담당해야한다. 이렇게 변경하면 단순히 유스 케이스는 DTO 클래스로 넘어온 데이터를 가공해서
order 엔티티에 넘겨준다.

책임을 중앙 집중화된 형태에서 개별 책임으로 넘겨준다. 주문의 경우는 Order 유스 케이스의 order 메서드가 엔트리 포인트가 된다.
---

## 2. 객체 지향
domain 디렉터리

## 3. 역할, 책임, 협력
객체지향은 객체를 중심에 놓는 프로그래밍 패러다임이다. 객체는 상태와 행동을 함께 캡슐화하는 실행 단위다.

객체 지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다. 클래스와 상속은 구현 메커니즘일 뿐이다. 역할과 책임, 협력을 충분히 고려하지 않은 채 너무 이른 시기에 구현에 초점을 맞추면 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.

객체는 아는 것과 하는 것으로 구분 된다.
1. 아는 것은 컨스트럭터를 통해 주입받는다.
2. 하는 것은 스스로 할 수 없다면 주입받은 객체
에 메시지를 보내서 도움을 요청한다. (협력을 요청한다.)

### 협력
협력은 문맥을 제공한다. (여기서 문맥이란 메시지 플로우다.)

### 책임
객체지향에서 가장 중요한 것은 책임이다. 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정한다.

## 역할
(역할은 추상화의 개념을 생각하자. discountPolicy, 추상 클래스가 그 예시)
역할을 구현하는 가장 일반적인 방법은 협력의 관점에서 추상 클래스와 인터페이스를 사용하는 것

객체 대 역할
역할을 다양한 객체가 그 책임을 수행할 수 있는 것
객체는 오로지 한 객체만 책임을 수행함
설계 초반 역할과 객체의 구분이 쉽지 않다면 CRC카드처럼 Candidate로 두는 것이 합리적이다.

역할의 가장 큰 장점은 설계 시 구성요소를 추상화할 수 있다는 점이다. 
즉 이를 슬롯으로 바라보면 미래에 추가될 미지의 할인 정책 등을 유연하게 추가할 수 있게 된다.

협력 - 메시지
책임 - 행동
역할 - 추상화

즉 도메인 주도 설계를 함에 있어서,
1. 메시지를 먼저 생각한다.
2. 협력의 관점에서 메시지를 어떤 전문가 객체에게 보낼지 결정한다.
3. 이를 위한 각 후보(객체 혹은 역할)들은 무엇을 알고 무엇을 하는가 정리한다.
4. 만약 후보가 한 명이라면 구체적인 객체로, 여러 후보가 동시에 존재할 수 있다면 역할이 합리적이다.
---

왜 DiscountPolicy랑 DiscountCondition을 분리했을까?

DiscountPolicy는 계산 할 수 있다(행동). 그런데 계산을 하기 위해서는
조건이 필요하다(아는 것). 즉 조건을 알아야 한다. 아는 것은 주입받아야 한다.
이를 객체로 분리해서 관리하면 조건을 유연하게 추가하고 삭제 할 수 있다.

---
## 4. 데이터 품질과 트레이드오프
데이터 중심 설계의 문제점
- 캡슐화 위반: getOO, setOO 메서드는 내부 데이터를 외부로 노출한다. 따라서 private으로 필드를 선언하는 의미 자체가 없다.
- 낮은 응집도: 책임이 분산된다. 한 가지 기능을 수정하면 여러 객체를 동시에 수정하게 된다.
- 높은 결합도: get, set 메서드를 통해 제공하는 필드가 수정되면? 이를 사용하는 객체도 전부 수정해야한다.

## 5. 책임 할당하기
책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 책임 할당이다. 이를 위한 기법으로 GRASP(General Responsibility Assignment Software pattern)이 있다.

## 6. 메시지와 인터페이스
객체지향 애플리케이션의 가장 중요한 재료는 객체들이 주고 받는 메시지다. 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다. 
(메서드라는 인터페이스만 퍼블릭이고 내부 정보는 모두 감춰서 결합도를 낮춰야한다.)

## 7. 객체 분해
문제 해결에 필요한 요소의 수가 단기 기억을 초과하는 경우 문제 해결 능력이 급격하게 떨어진다. 이것이 인지 과부하다. 그러므로 해결 가능한 작은 단위로 분해해야 한다. 이는 객체의 추상화 단계에도 동일하게 적용된다. 너무 많은 일을 다양하게 하는 객체는 인지 과부하를 불러일으킨다.

## 8. 의존성 관리하기
협력은 필수적이지만 과도한 협력은 설계를 망가뜨린다. 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서, 변경을 방해하는 의존성은 제거하는 것이다.

- 컴파일 타임 의존: 코드를 작성하는 시점에서의 의존성
- 런타임 의존: 말그대로 런타임에서의 의존성이다. 런타임 의존이 가능하므로 다형성을 구현할 수 있다. 즉 인터페이스에 의존하게 할 수 있음을 의미한다.

## 9. 유연한 설계
- OCP
- DI
- DIP

## 10. 상속과 코드 재사용
상속: 강한 결합도, 높은 코드 재사용성
합성: 낮은 결합도, 퍼블릭 인터페이스 의존

## 11. 합성과 유연한 설계
상속은 Is-a 관계이며 서브클래싱에 의한 재사용으로 화이트박스 재사용이라고 부른다.
합성은 Has-a 관계이며 서브타이핑에 의한 재사용으로 블랙박스 재사용이라고 부른다.

## 12. 다형성
상속의 목적은 코드 재사용이 아니라 타입 계층을 구조화하기 위함이다.


## 13. 서브클래싱과 서브타이핑
상속을 사용하는 이유는 일반화와 특수화를 통한 타입 계층을 만들기 위함이다. 타입 사이의 관계를 고려하지 않고 단순히 코드 재사용을 위해 상속을 사용하면 코드 결합도가 높아지는 문제가 발생한다.

## 14. 일관성 있는 협력
객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다. 하지만 재사용은 공짜로 얻어지지 않는다. 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어주어야 한다. 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용한다.

## 15. 디자인 패턴과 프레임워크
디자인 패턴: 소프트웨어 설계에서 반복적으로 적용할 수 있는 해결 방법
프레임워크: 설계와 코드를 함께 재사용하기 위해 애플레킹션의 아키텍처를 구현 코드의 형태로 제공한다.

디자인 패턴과 프레임워크 모두 일관성 있는 협력과 관련이 있다. 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 패턴을, 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다. (스프링 프레임워크의 핸들러 어댑터 패턴과 프록시 패턴을 떠올려 보면 된다. 스프링은 확장 가능한 코드 템플릿을 제공하기 위해 프록시 패턴을 유사한 방법으로 반복해서 사용한다.)
----

책이 큰 측면에서 보면
1. 객체지향 설계와 데이터 중심 설계의 차이
2. 서브클래싱과 서브타이핑(상속과 협력) 