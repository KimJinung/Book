# 1.협력하는 객체들의 공동체
## 객체 지향
시스템의 행위를 구현하기 위해서, 객체들이 주어진 역할에 대한 책임을 다하며 협력하는 것이 객체 지향이다. 각 객체는 다른 객체가 어떤 역할을 담당하는지 정확히 알고 있지만, 그 객체가 주어진 역할에 대한 책임을 다하기 위해서 어떠한 방식으로 일을 처리하는지는 관여하지 않는다. 즉 객체는 역할에 대한 책임을 자유롭게 처리한다.
# 2.이상한 나라의 객체
## 표현적 갭 - 현실 세계와 객체 지향은 다르다.
객체 지향을 현실 세계의 사물과 비교하는 이유는, 이러한 은유를 통해 표현적 차이를 줄임으로써 각 객체의 이름만으로도 해당 객체의 '행동'을 예측할 수 있기 때문이다. 

## 상태가 아닌 행동에 주목하자.
객체에서 주목해야 할 대상은 상태(데이터)가 아닌, 행동이다. 객체 지향에서 중요한 것은 해당 객체의 상태가 아니라 객체가 어떠한 책임을 다 할 수 있는지, 즉 행동에 관심을 가지기 때문이다.

## 메시지
객체는 객체 스스로 수행할 수 없는 책임은 다른 객체에 책임을 위임한다. 이때 객체는 메시지를 통해 다른 객체에 책임을 전달한다.

# 3. 타입과 추상화
## 타입 시스템 존재의 의의
타입 시스템은 데이터를 잘못 사용하지 못하도록 제약사항을 부과한다. 예를 들어서 메모리 안에 저장된 0과1 에 대해서 수행 가능 및 불가능한 작업을 분류하여 데이터가 잘못 사용되는 것을 방지한다. 이 과정에서 타입에 속한 데이터를 표현하는 방식은 외부로부터 철저히 감춰진다. 개발자는 데이터의 타입 표현 방식을 모르더라도 데이터를 사용하는 데에는 지장이 없다. 이것이 추상화다. 훌륭한 객체지향 설계의 원칙은 외부에 행동만 제공하고, 데이터는 행동 뒤로 감춘다. 이렇듯 객체의 자율성을 보장하기 위해 구현을 외부로 부터 감추는 것을 캡슐화라고 한다.

1. 타입은 데이터를 잘못 사용하지 못하도록 제약사항을 부과한다.
2. 객체가 수행하는 행동의 구체적인 방법은 추상화 된다.
    - 메시지 요청자의 관심은 그 객체가 수행하는 행동의 결과일 뿐이다.

 Java 언어는 Integer 타입을 제공한다. 개발자는 Integer class의 제약 사항에 의해 데이터를 잘못 사용하지 않도록 제약 당한다. 그리고 개발자는 Integer 타입이 제공하는 행동에 메시지를 전달하고 그 결과를 제공받는다. 메시지를 통해 요청 할 뿐, 내부의 구체적인 구현에는 관심을 가지지 않는다.

## LSP
위 내용을 통해서 LSP(Liskov Substitution Principle)을 더 깊게 이해할 수 있다. "LSP의 대전제는 상속을 통해 구현한 하위 타입이 상위 타입 대신 치환되었을 때, 행위가 변하지 않는 다면 해당 구현체는 상위 타입의 하위 타입이다." 이다. 

LSP는 객체에서 행동과 행동의 추상화에 대한 중요함을 되돌아볼 수 있는 원칙이다. Sub type은 Super type이 할 수 있는 행동을 모두 할 수 있으면서 추가적인 행동을 할 수 있는 타입이다. 만약 Sub type이 super type과 동일한 요청을 받았을 때 내부적으로 다른 방식으로 처리하더라도 그 행동의 결과가 같다면 Super type의 구현이다. 즉 객체에서 가장 중요한 요소는 상태가 아니라 그 객체가 제공하는 행동이다.

## 동적 모델과 정적 모델
객체의 동적인 상태를 표현하는 모델을 Dynamic model이라고 한다. 이것은 런타임 중 객체의 데이터가 변하는 상태를 말한다. 그리고 특정 시점의 상태를 포착하는 것을 Snapshot이라고 한다. 다음으로 객체의 상태가 아니라 객체가 가질 수 있는 모든 상태와 행동을 시간 독립적으로 표현하는 것을 Static model이라고 한다.

개발자는 시간에 독립적인 객체를 구현하기 위해 정적인 모델로 코드를 작성한다. 이를 위해 사용하는 도구가 class다. 주의할 점은, class와 type은 동등한 관계가 아니다. class는 type의 sub type 관계에 가깝다. class는 타입 구현 뿐만 아니라 코드 재사용에도 이용할 수 있다. 

# 4.역할, 책임, 협력
## 역할과 책임
역할은 책임의 집합이다. 책임이란 어떤 요청에 대해서 행동을 해야하는 것을 의미한다. 그리고 이러한 공통되고 유사한 책임들의 모여서 하나의 역할을 만든다. 이것이 객체가 지니고 있는 특성이다. 

## 협력
객체는 자신이 처리할 수 없는 행동을, 처리할 수 있는 객체에 메시지를 전송한다. 메시지를 수신한 객체가 메시지를 처리할 수 없다면 자신이 알고 있는 해당 역할을 수행할 수 있는 객체를 찾는다. 이것이 객체 간의 협력이다.

## 책임 주도 설계(Responsibility-Driven-Design, RDD)
객체를 먼저 생각하지 않고, 메시지를 먼저 생각하고 공통된 메시지를 처리하는 역할을 분리하여 설계하는 방법이다.

# 5. 책임과 메시지
## 메시지와 메서드
객체에게 책임을 요청하기 위해 메시지를 보낸다. 수신자 역할에 해당하는 객체는 메시지 이름과 인자를 기준으로 메시지에 응답한다. 

```java
int day = date.getDate(2023, 04, 21)
```

위 코드에서 day는 송신자, date는 수신자 객체, getDate는 메시지 이름이자 메서드, 날짜 값은 인자에 해당한다.

## 인터페이스와 구현
객체는 외부와 내부가 철저하게 분리되어 있다. 외부에 공개되어 있는 것을 Common interface 그리고 내부를 Implentation이라고 한다. 좋은 설계란 인터페이스를 가능한 추상화하고 구체적이지 않은 상태로 유지하는 것이다. 인터페이스가 구체적일 수록 변경에 취약하다. 

## 인터페이스에 의존하라
객체 지향 설계가 가진 다형성의 이점은 메시지 송신자가 추상화된 인터페이스에 의존함으로써 메시지에 응답하는 수신자 객체 내부의 구현이 변경되거나 객체 자체가 바뀌더라도 메시지를 요청하는 수신자 측은 전혀 신경쓰지 않아도 된다는 것이다.

## "어떻게"가 아니라 "무엇"을 요청하라
메시지를 요청하는 측에서 행동에 대한 어떻게(How)를 제약하면, 객체 간의 결합도가 강해진다. 메시지를 통해 요청하는 행동이 구체적이지 않고, 추상화될 수록 객체 간의 결합도를 느슨하게 만들고 더욱 협력에 유연하게 만들 수 있다.

(개인적으로 이 부분에 집중해서 개발할 필요성이 있어보인다.)

# 6. 객체 지도
## 구조적이고 문제 지향적인 접근법
지하철 노선도는 실제 지형과 거리는 무시했지만, 지하철 이용객이 필요로 하는 정차 지점과 환승 지점에 집중했다. 이는 객체를 디자인 함에 있어서 무엇이 필요하고 필요없는 가를 잘 보여주는 대표적인 예시다.

## 기능 설계 vs 구조 설계
성공적인 소프트웨어들이 지닌 공통적인 특징은 훌륭한 기능을 제공하는 동시에 사용자가 원하는 새로운 기능을 빠르고 안정적으로 추가할 수 있다는 점이다.

설계가 어려운 이유는 어제 약속했던 기능을 제공하는 동시에 내일 변경될지도 모르는 요구사항도 수용할 수 있는 코드를 창조해야 하기 때문이다.

미래에 대비하는 가장 좋은 방법은 미래를 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다.

지도 은유처럼 변경에 대비하고 변경의 여지를 남겨 놓는 가장 좋은 장법은 자주 변경되는 기능이 아닌, 지형 같은 잘 변하지 않는 안정적인 구조를 중심으로 설계하는 것이다. 

## 도메인 모델: 안정적인 재료: 구조
도메인 모델은 이해관계자들이 바라보는 멘탈 모델이다. 멘탈 모델이란 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다. 사람의 인지능력은 제한적이라 자신을 둘러싼 객체들의 공통점을 기준으로 추상화하여 인식한다.

## 유스 케이스: 불안정한 재료: 기능
기능적 요구사항으로 시스템이 사용자에게 제공해야하는 기능 항목이다. (쉽게 말해서 서비스 레이어에 해당하는 것들이다.)


객체 설계는 다음과 같이 표현되기도 한다. 

요구사항들을 식별하고 도메인 모델을 생성한 후, 소프트웨어 클래스에 메서드들을 추가하고, 요구사항을 충족시키기 위해 객체들 간의 메시지 전송을 정의하라[Larman 2001]

# 7. 함께 모으기
## 개념 관점(Conceptual Perspective)
도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.

## 명세 관점(Specification Perspective)
객체들의 책임에 초점을 맞춘 관점이다. 즉 객체의 인터페이스를 바라보는 관점이다.

## 구현 관점(Implementation Perspective)
실제 작업을 수행하는 코드와 관련된 관점이다.

---

주의할 점은 위 세 가지 관점을 순서대로 작업하라는 의미가 아니라, 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다. 이것은 클래스를 어떻게 설계해야 하느냐에 대한 중요한 힌트를 암시한다. 클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 그리고 동시에 코드 안 에서 세가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다. 