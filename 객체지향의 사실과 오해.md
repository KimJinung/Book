# 1.협력하는 객체들의 공동체
시스템의 행위를 구현하기 위해서 객체들이 주어진 역할에 대한 책임을 다하며 협력하는 것이 객체지향이다. 각 객체는 다른 객체가 어떤 역할을 담당하는지는 정확히 알고 있지만, 그 객체가 주어진 역할에 대한 책임을 위해 어떠한 방식으로 처리하는지는 알지 못한다. (즉 역할이라는 폐쇄적인 속성을 가지지만, 행위는 자유롭다. OCP 원칙)

# 2.이상한 나라의 객체
객체에서 주목해야할 것은 상태가 아니라, 그 객체의 행동이다. 객체지향을 현실 세계의 사물과 비교하는 이유는 이러한 은유를 통해 표현적 차이를 줄임으로서 각 객체의 이름만으로도 해당 객체의 '행동'을 예측할 수 있기 때문이다.

각 객체는 메시지를 다른 객체에 요청할 뿐이다. 요청(메시지)를 전달 받은 객체는 그 역할에 대한 책임을 스스로 결정하고 행동한다. 

Reference object와 value object의 가장 큰 차이점은 식별자의 유무다. Integer, String과 같은 value object는 식별자가 없다. 반면에 Reference object는 객체로써 식별자를 가지고 있다. 따라서 Value object는 equal(동등성)을 기준으로 비교 한다. 그리고 Referenct object는 식별자를 가지므로 identical(동일성)을 기준으로 비교한다.

# 3. 타입과 추상화
## 타입 시스템 존재의 의의
타입 시스템은 데이터를 잘못 사용하지 못하도록 제약사항을 부과한다. 타입 시스템의 목적은 메모리 안에 저장된 0과1 에 대해서 수행 가능 및 불가능한 작업을 분류하여 데이터가 잘못 사용되는 것을 방지한다. 그리고 이 과정에서 타입에 속한 데이터를 표현하는 방식은 외부로부터 철저히 감춰진다. 개발자는 데이터의 타입 표현 방식을 모르더라도 데이터를 사용하는 데에는 지장이 없다. 이것이 추상화다. 훌륭한 객체지향 설계의 원칙은 외부에 행동만 제공하고, 데이터는 행동 뒤로 감춘다. 이러한 방식이 캡슐화다. (객체가 가지는 데이터가 아니라 객체의 행동을 먼저 생각하게 만든다.)

(위 내용을 통해서 LSP(Liskov Substitution Principle)을 더 깊게 이해할 수 있다. "LSP의 대전제는 상속을 통해 구현한 하위 타입이 상위 타입 대신 치환되었을 때, 행위가 변하지 않는 다면 해당 구현체는 상위 타입의 하위 타입이다." 이다. 

LSP는 객체에서 그 무엇보다도 행동이 중요함을 되돌아볼 수 있는 원칙이다. Sub type은 super type이 할 수 있는 행동을 모두 할 수 있으면서 추가적인 행동을 할 수 있는 타입이다. 만약 Sub type이 super type과 동일한 요청을 받았을 때 내부적으로 다른 방식으로 처리하더라도 그 행동의 결과가 같다면 Super type의 구현이다. 즉 객체는 주어진 역할과 책임에 대해 추상화된 행동으로 응답한다.)

## 동적 모델과 정적 모델
객체의 동적인 상태를 표현하는 모델을 Dynamic model이라고 한다. 이것은 런타임 중 객체의 데이터가 변하는 상태를 말한다. 그리고 특정 시점의 상태를 포착하는 것을 snapshot이라고 한다. 다음으로 객체의 상태가 아니라 객체가 가질 수 있는 모든 상태와 행동을 시간 독립적으로 표현하는 것을 Static model이라고 한다.

## Conclusion
- 1. 데이터를 잘못 사용하지 못하도록 제약사항을 부과하는 것이 타입이다.
- 객체를 이용하여 타입을 구현할 수 있다.
- 2. 객체가 수행하는 행동의 구체적인 방법은 추상화 된다. (메시지 요청자의 관심은 그 객체가 수행할 수 있는 행동이지, 구체적인 방법이 아니다. 즉 객체를 사용하는 이유는 제약사항을 부과하고, 추상화된 형태로 행동을 제공하는 것에 있다.)
- 개발자는 시간에 독립적인 객체를 구현하기 위해 정적인 모델로 코드를 작성한다. 이때 사용하는 것이 class라는 도구다. (class 내부 필드에 타입을 명시해서 특정 필드의 값에 제약사항을 부과한다.)
- class와 type은 동일하지 않다. Super/Sub type 관계에 가깝다. class는 타입 구현 뿐만 아니라 코드 재사용에도 이용할 수 있다.
- 타입을 나누는 기준은 객체가 수행하는 행동이다. (다시 LSP와 연결된다. 자바는 Integer라는 타입을 class라는 도구를 이용해서 객체로 구현했다. Integer 클래스는 해당 클래스가 가진 데이터가 중요한 게 아니라 Integer 클래스가 제공하는 행동이 중요하다. 개발자는 Integer 클래스가 가지고 있는 데이터가 아니라 해당 객체가 제공하는 행동에 더 관심을 가진다. Integer 클래스는 숫자 데이터를 사용하는 방법에 제약사항을 부과한다. 그리고 숫자 데이터 조작에 대한 구체적인 구현은 추상화된 형태로 제공한다. 이러한 방법을 통해서 메시지 요청자는 특정 객체가 어떠한 역할과 책임이 있고 어떠한 제약사항이 있는지만 알면 내부의 구체적인 구현을 몰라도 된다. -> DIP로 이어진다.)


객체는 요청에 제약사항을 부여하고 특정 행위를 대신 해주는 무언가로 정의할 수 있지 않을까?

