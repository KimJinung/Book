# 1.협력하는 객체들의 공동체
시스템의 행위를 구현하기 위해서 객체들이 주어진 역할에 대한 책임을 다하며 협력하는 것이 객체지향이다. 각 객체는 다른 객체가 어떤 역할을 담당하는지는 정확히 알고 있지만, 그 객체가 주어진 역할에 대한 책임을 위해 어떠한 방식으로 처리하는지는 알지 못한다. (즉 역할이라는 폐쇄적인 속성을 가지지만, 행위는 자유롭다. OCP 원칙)

# 2.이상한 나라의 객체
객체에서 주목해야할 것은 상태가 아니라, 그 객체의 행동이다. 객체지향을 현실 세계의 사물과 비교하는 이유는 이러한 은유를 통해 표현적 차이를 줄임으로서 각 객체의 이름만으로도 해당 객체의 '행동'을 예측할 수 있기 때문이다.

각 객체는 메시지를 다른 객체에 요청할 뿐이다. 요청(메시지)를 전달 받은 객체는 그 역할에 대한 책임을 스스로 결정하고 행동한다. 

Reference object와 value object의 가장 큰 차이점은 식별자의 유무다. Integer, String과 같은 value object는 식별자가 없다. 반면에 Reference object는 객체로써 식별자를 가지고 있다. 따라서 Value object는 equal(동등성)을 기준으로 비교 한다. 그리고 Referenct object는 식별자를 가지므로 identical(동일성)을 기준으로 비교한다.

# 3. 타입과 추상화
## 타입 시스템 존재의 의의
타입 시스템은 데이터를 잘못 사용하지 못하도록 제약사항을 부과한다. 타입 시스템의 목적은 메모리 안에 저장된 0과1 에 대해서 수행 가능 및 불가능한 작업을 분류하여 데이터가 잘못 사용되는 것을 방지한다. 그리고 이 과정에서 타입에 속한 데이터를 표현하는 방식은 외부로부터 철저히 감춰진다. 개발자는 데이터의 타입 표현 방식을 모르더라도 데이터를 사용하는 데에는 지장이 없다. 이것이 추상화다. 훌륭한 객체지향 설계의 원칙은 외부에 행동만 제공하고, 데이터는 행동 뒤로 감춘다. 이러한 방식이 캡슐화다. (객체가 가지는 데이터가 아니라 객체의 행동을 먼저 생각하게 만든다.)

(위 내용을 통해서 LSP(Liskov Substitution Principle)을 더 깊게 이해할 수 있다. "LSP의 대전제는 상속을 통해 구현한 하위 타입이 상위 타입 대신 치환되었을 때, 행위가 변하지 않는 다면 해당 구현체는 상위 타입의 하위 타입이다." 이다. 

LSP는 객체에서 그 무엇보다도 행동이 중요함을 되돌아볼 수 있는 원칙이다. Sub type은 super type이 할 수 있는 행동을 모두 할 수 있으면서 추가적인 행동을 할 수 있는 타입이다. 만약 Sub type이 super type과 동일한 요청을 받았을 때 내부적으로 다른 방식으로 처리하더라도 그 행동의 결과가 같다면 Super type의 구현이다. 즉 객체는 주어진 역할과 책임에 대해 추상화된 행동으로 응답한다.)

## 동적 모델과 정적 모델
객체의 동적인 상태를 표현하는 모델을 Dynamic model이라고 한다. 이것은 런타임 중 객체의 데이터가 변하는 상태를 말한다. 그리고 특정 시점의 상태를 포착하는 것을 snapshot이라고 한다. 다음으로 객체의 상태가 아니라 객체가 가질 수 있는 모든 상태와 행동을 시간 독립적으로 표현하는 것을 Static model이라고 한다.

## Conclusion
- 1. 데이터를 잘못 사용하지 못하도록 제약사항을 부과하는 것이 타입이다.
- 객체를 이용하여 타입을 구현할 수 있다.
- 2. 객체가 수행하는 행동의 구체적인 방법은 추상화 된다. (메시지 요청자의 관심은 그 객체가 수행할 수 있는 행동이지, 구체적인 방법이 아니다. 즉 객체를 사용하는 이유는 제약사항을 부과하고, 추상화된 형태로 행동을 제공하는 것에 있다.)
- 개발자는 시간에 독립적인 객체를 구현하기 위해 정적인 모델로 코드를 작성한다. 이때 사용하는 것이 class라는 도구다. (class 내부 필드에 타입을 명시해서 특정 필드의 값에 제약사항을 부과한다. method에 파라미터를 명시하여 제약사항을 부과한다.)
- class와 type은 동일하지 않다. Super/Sub type 관계에 가깝다. class는 타입 구현 뿐만 아니라 코드 재사용에도 이용할 수 있다.
- 타입을 나누는 기준은 객체가 수행하는 행동이다. (다시 LSP와 연결된다. 자바는 Integer라는 타입을 class라는 도구를 이용해서 객체로 구현했다. Integer 클래스는 해당 클래스가 가진 데이터가 중요한 게 아니라 Integer 클래스가 제공하는 행동이 중요하다. 개발자는 Integer 클래스가 가지고 있는 데이터가 아니라 해당 객체가 제공하는 행동에 더 관심을 가진다. Integer 클래스는 숫자 데이터를 사용하는 방법에 제약사항을 부과한다. 그리고 숫자 데이터 조작에 대한 구체적인 구현은 추상화된 형태로 제공한다. 이러한 방법을 통해서 메시지 요청자는 특정 객체가 어떠한 역할과 책임이 있고 어떠한 제약사항이 있는지만 알면 내부의 구체적인 구현을 몰라도 된다. -> DIP로 이어진다.)


객체는 요청에 제약사항을 부여하고 특정 행위를 대신 해주는 무언가로 정의할 수 있지 않을까?

# 4.역할과 책임 협력
역할은 책임의 집합이다. 나는 이 순서를 다시 재배열해서 책임과 역할 그리고 협력이라고 다시 써보고 싶다.
책임이란 어떤 요청에 대해서 행동을 해야하는 것을 의미한다. 그리고 이러한 공통되고 유사한 책임들의 모여서 하나의 역할을 만든다.
이것이 객체가 지니고 있는 특성이다. 그리고 객체는 자신이 처리할 수 없는 행동을, 처리할 수 있는 객체에 메시지를 전송한다. 메시지를 수신한 객체가
만약 처리할 수 없다면 자신이 알고 있는 해당 역할을 수행할 수 있는 객체를 찾는다. 예시를 한 가지 들어서, 컨트롤러 레이어에 해당하는 객체는 밸리데이션을 진행하고
서비스 레이어에 비지니스 로직을 수행할 것을 메시지로 요청한다. 이때 컨트롤러 레이어는 서비스 레이어 내에서 일어나는 일에 대해서는 전혀 알지 못한다.
서비스 레이어는 비지니스 로직을 수행하기 위해 필요한 추가적인 데이터를 리포지토리 레이어에 요청한다. 

위와 같이 행동이 구체적이지 않고, 추상화된 방법을 통해 객체간의 결합도를 느슨하게 만들고 더욱 협력에 유연하게 만들 수 있다.


# 5. 타입과 메시지
책임 주도 설계는 객체를 먼저 생각하지 않고 메시지를 먼저 생각하고 공통된 메시지를 처리하는 역할을 분리하여 설계하는 방법이다.
객체에게 요청하기 위해 메시지를 보낸다. 이때 인자를 넘긴다. 수신자 역할에 해당하는 객체는 메시지 이름과 인자를 기준으로 이에 응답한다.
이를 처리하는 방법을 메서드라고 한다.

객체는 외부와 내부가 철저하게 분리되어 있다. 외부에 공개되어 있는 것을 공통 인터페이스, 그리고 내부를 Implentation이라고 한다. 
좋은 설계란 인터페이스를 가능한 추상화하고 구체적이지 않은 상태로 유지하는 것이다. 인터페이스가 구체적일 수록 변경에 취약하다.
객체지향 설계가 가진 다형성의 이점은 이와 같이 메시지 송신자가 추상화된 인터페이스에 의존하면 메시지에 응답하는 객체 그리고 그 객체의 구현이 바뀌더라도 전혀 신경쓰지 않아도 된다.

즉 컨트롤러 레이어는 서비스 레이어 인터페이스에 의존한다. 서비스 레이어 인터페이스는 컨트롤러의 존재 자체를 알지 못해도 상관이 없다.
단순히 서비스 레이어 역할에 해당하는 객체는 어떠한 메시지가 넘어올 것이라는 것만 알고 그에 대한 구현만 작성하면 된다.
이러한 방식으로 객체는 자율성을 최대한 보장받는다.

서비스 레이어와 리포지토리 레이어도 마찬가지다. 서비스 레이어는 리포지토리 레이어가 어떤 방식으로 데이터를 디비에서 가져오는지 전혀 신경 쓰지 않는다.
리포지토리 레이어의 인터페이스를 참조해서 필요한 행동을 메시지로 전송한다. 그리고 결과만 받는다. 서비스 레이어는 리포지토리 레이어의 인터페이스에 의존한다.
리포지토리 레이어의 인터페이스를 구현한 객체들은 서비스 레이어의 객체를 알 필요가 없다. 

# 6. 객체 지도
추상화가 잘 된 대표적인 예시는 지하철 노선도다. 지하철 노선도는 실제 지형과 거리는 무시했지만, 지하철 이용객이 필요로 하는 정차 지점과 환승 지점에만 집중했다.

- 도메인 모델: 도메인은 모델은 이해관계자들이 바라보는 멘탈 모델이다. 멘탈 모델이란 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다. (사람의 인지능력은 제한적이라 자신을 둘러싼 객체들의 공통점을 기준으로 추상화하여 인식한다.)
- 유스케이스: 기능적 요구사항으로 시스템이 사용자에게 제공해야하는 기능 항목이다. (쉽게 말해서 서비스 레이어)

# 7. 함께 모으기
- 개념 관점(Conceptual Perspective)
- 명세 관점(Specification Perspective)
- 구현 관점(Implementation Perspective)

개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 명세 관점은 객체들의 책임에 초점을 맞춘다. 즉 객체의 인터페이스를 바라보는 관점이다. 마지막으로 구현 관점은 실제 작업을 수행하는 코드와 관련되어 있다.

주의할 점은 위 세 가지 관점을 순서대로 작업하라는 의미가 아니라, 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다. 코드는 세 가지 관점을 모두 제공해야 한다.
